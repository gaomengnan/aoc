#+title: Element with left side smaller and right side greater


*** Desc

Given an unsorted array of arr. Find the first element in an array such that all of its left elements are smaller and all right elements of its are greater than it.

Note: Return -1 if there is no such element.


**** Examples

#+begin_example
Input: arr = [4, 2, 5, 7]
Output: 5
Explanation: Elements on left of 5 are smaller than 5 and on right of it are greater than 5.

Input: arr = [11, 9, 12]
Output: -1
Explanation: As no element here which we can say smaller in left & greater in right.
#+end_example


*** Approach

题目要求 大于左边的 并且小于右边的

==转换为满足条件 大于左边的最大值  小于右边最小值==


#+begin_src c
#include <algorithm>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
  int findElement(vector<int> &arr) {
    int n = arr.size();
    vector<int> lefts(n, 0);
    vector<int> rights(n, 0);
    int maxVal = INT_MIN;
    for (int i = 0; i < n; i++) {
      lefts[i] = maxVal;
      maxVal = max(maxVal, arr[i]);
    }

    int minVal = INT_MAX;
    for (int i = n - 1; i >= 0; --i) {
      rights[i] = minVal;
      minVal = min(minVal, arr[i]);
    }
    for (int i = 1; i < n-1; i++) {
      if (arr[i] > lefts[i] && arr[i] < rights[i]) {
        return arr[i];
      }
    }
    return -1;
  }
};

int main() {
  Solution sol;
  vector<int> arr = {56, 61, 55, 84, 51, 26, 51, 23, 44, 68};
  // 0 5 -5 33 -23 -25 28 -28 21 24
  int index = sol.findElement(arr);
  cout << "Index of the element: " << index << endl;
  return 0;
}

#+end_src
