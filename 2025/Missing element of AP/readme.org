#+title: Missing element of AP

*** desc

Given a sorted array arr[] that represents an Arithmetic Progression (AP) with exactly one missing element, find the missing number.
The array arr[] is sorted in either ascending or descending order.

Note: An element will always exist that, upon inserting into a sequence forms Arithmetic progression. If the given sequence already forms a valid complete AP, return the (n+1)-th element that would come next in the sequence.


**** Examples
#+begin_example
Input: arr[] = [2, 4, 8, 10, 12, 14]
Output: 6
Explanation: Actual AP should be 2, 4, 6, 8, 10, 12, 14.

Input: arr[] = [1, 6, 11, 16, 21, 31]
Output: 26
Explanation: Actual AP should be 1, 6, 11, 16, 21, 26, 31.

Input: arr[] = [4, 7, 10, 13, 16]
Output: 19
Explanation: Since the sequence already forms a valid AP, the next element after 16 in the sequence would be 19. Therefore, the output is 19.
#+end_example


*** Approach

#+begin_src c
#include <algorithm>
#include <iostream>
#include <print>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

// User function template for C++

class Solution {
public:
  int findMissing(vector<int> &arr) {
    int n = arr.size();
    // int k_sum = (arr[0] + arr[n - 1]) * n / 2;
    long long  total = 0;
    unordered_map<int, int> mp;

    for (int i = 1; i < n; ++i) {
      mp[arr[i] - arr[i - 1]]++;
    }
    long long first = arr[0];
    long long second =  arr[1];
    long long last = arr[n-1];

    //  说明这个是个完整de等差
    if (mp.size() == 1) {
      return last + (second - first);
    }

    // print("k sum is {} \n", mp);
    for (int i = 0; i < n; ++i) {
      total += arr[i];
    }

    long long  z_sum = (first + last) * (n + 1) / 2;

    return z_sum - total;
  }
};
int main() {
  Solution sol;
  // $S_n = \frac{n}{2}(a_1 + a_n)$
  // 65 - 52

  vector<int> arr = {0,1,2,3,4,5,7,8};
  int missing = sol.findMissing(arr);
  cout << "Missing number is: " << missing << endl;
  return 0;
}

#+end_src
