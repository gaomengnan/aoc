* 差值为k的数对
给定一个正整数数组arr[]。找出绝对差值等于给定数字k的整数对的数量。
注意：(a, b)和(b, a)被视为相同。此外，不同索引处的相同数字被视为不同的元素。

** 问题描述 **
给定一个整数数组和一个目标差值k，计算满足|arr[i] - arr[j]| = k的数对(i, j)的数量，其中i ≠ j。

** 示例 **
- 输入：arr = [1, 1, 1, 4, 5, 6], k = 7
  输出：3
  解释：数对为(1,6), (1,6), (1,6)

- 输入：arr = [8, 16, 12, 16, 4, 0], k = 4
  输出：5
  解释：数对为(8,12), (12,16), (12,16), (16,20), (0,4)

- 输入：arr = [2, 2, 2, 2], k = 0
  输出：6
  解释：每个元素与其他所有元素配对

** 解决方法 **
1. **频率统计**：使用Counter统计数组中每个数字的出现次数
2. **数对搜索**：对于数组中的每个元素，检查是否存在满足差值条件的另一个元素
3. **重复处理**：当k = 0时（相同元素配对）和目标等于当前元素时的特殊处理

** 算法 **
1. 创建数组中所有元素的频率字典
2. 初始化count = 0
3. 对于数组中的每个元素：
   - 计算target = element + k
   - 如果target存在于频率字典中：
     - 如果target == element（k = 0的情况）：加上frequency[target] - 1
     - 否则：加上frequency[target]
4. 返回count

** 复杂度分析 **
- 时间复杂度：O(n)，其中n是数组中元素的数量
- 空间复杂度：O(n)，用于存储频率字典

** 代码实现 **
#+BEGIN_SRC python
# User function Template for python3
from collections import Counter


class Solution:
    def countPairs(self, arr, k):
        carr = Counter(arr)
        count = 0
        for i in arr:
            if carr[k + i] > 0:
                if k + i == i:
                    count += carr[k + i] - 1
                else:
                    count += carr[k + i]
                # carr[i] -= 1

        return count


print(Solution().countPairs([8, 16, 12, 16, 4, 0], 4))
#+END_SRC


** 双指针

O(nlogn)
先要排序

#+begin_src python
from collections import Counter


class Solution:
    def countPairs(self, arr, k):

        # O(nlog^n)
        arr.sort()
        # k = 3
        # 1 1 4 4 5
        # 1 5 x
        # 1 4
        # 1 4
        # 0 4 8 12 16 16
        # 1, 1, 1, 4, 5, 6 k=7

        n = len(arr)

        i = 0
        j = 0

        cnt = 0

        while j < n:

            if arr[j] - arr[i] < k:
                j +=1
            elif arr[j]- arr[i] > k:
                i +=1

            else:
                el1 = arr[i]
                el2 = arr[j]

                ch1 = 0
                ch2 = 0

                while j < n and arr[j] == el2:
                    j +=1
                    ch2 +=1

                while i < n and arr[i] == el1:
                    i +=1
                    ch1 +=1

                if el1 == el2:
                    cnt += (ch1 * (ch1-1))

                else:
                    cnt += ch1 * ch2


        return cnt
#+end_src
