* 和最接近目标值的数对
给定一个数组 arr[] 和一个数字 target，请在 arr[] 中找到一对元素 (a, b)，其中 a ≤ b，使得 a + b 的和最接近 target。

** 注意：
- 返回的数对要按升序排列。
- 如果存在多个这样的数对，则返回 差值绝对值最大 的那个。
- 如果不存在这样的数对，则返回一个空数组。


** 解法

#+begin_src python :results output
class Solution:
    def sumClosest(self, arr, target):
        arr = sorted(arr)
        n = len(arr)

        left = 0
        right = n - 1
        if n == 1:
            return []

        ans = []
        bestDiff = float("inf")

        while left < right:
            currentSum = arr[left] + arr[right]
            currentDiff = abs(target - currentSum)

            if len(ans) == 0:
                ans = [arr[left], arr[right]]
                bestDiff = currentDiff
            else:
                if currentDiff < bestDiff or (
                    currentDiff == bestDiff and arr[right] - arr[left] > ans[1] - ans[0]
                ):
                    ans = [arr[left], arr[right]]
                    bestDiff = currentDiff

            if currentSum == target:
                return ans
            elif currentSum > target:
                right -= 1
            else:
                left += 1

        return ans


# 测试用例
print(Solution().sumClosest([10, 30, 20, 5], 25))  # 示例用法
print(Solution().sumClosest([1, 2, 3, 4, 5], 10))  # 目标等于最大对的和
print(Solution().sumClosest([1, 2, 3, 4, 5], 1))   # 目标小于最小对的和
print(Solution().sumClosest([1, 2, 3, 4, 5], 9))   # 目标接近最大对的和
print(Solution().sumClosest([1, 1, 1, 1], 2))      # 所有元素相同
print(Solution().sumClosest([-1, 2, 1, -4], 1))    # 包含负数
print(Solution().sumClosest([5], 10))              # 单个元素（应返回空数组）
print(Solution().sumClosest([1, 3, 5, 7, 9], 6))   # 多个对具有相同差值
#+end_src

#+RESULTS:
: [5, 20]
: [4, 5]
: [1, 2]
: [4, 5]
: [1, 1]
: [-1, 2]
: []
: [1, 5]
